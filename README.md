# CS-320

*Overview*

For this course, I have selected artifacts from both major projects to include in my portfolio repository. From Project One, I submitted the following files:

Contact.java

ContactService.java

ContactTest.java

ContactServiceTest.java

From Project Two, I submitted my Summary and Reflections Report.
These files showcase my skills in software testing, automation, and quality assurance. They demonstrate my ability to build classes, services, and corresponding unit tests to uncover errors, as well as to analyze software testing approaches based on requirements and apply effective testing strategies.

*Reflection*

How can I ensure that my code, program, or software is functional and secure?

To ensure that my software is functional and secure, I prioritize writing detailed unit tests that cover both expected behaviors and edge cases. I also validate all user inputs, use defensive coding practices, and follow secure design principles to minimize vulnerabilities. Regular testing, code reviews, and staying informed about secure coding standards are key steps I take to maintain both functionality and security throughout development.

How do I interpret user needs and incorporate them into a program?

I interpret user needs by thoroughly analyzing the project requirements and breaking them down into clear development goals. I approach this by thinking from the user's perspective, asking clarifying questions when needed, and using techniques like user stories to guide development. Continuous feedback loops and iterative testing also help ensure that the software I create truly aligns with user expectations.

How do I approach designing software?

When designing software, I focus on creating modular, scalable, and maintainable structures. I start by mapping out the program architecture, ensuring that each class or method has a single responsibility. I emphasize clear separation of concerns, reusable components, and clean, understandable code. Thoughtful planning, consistent naming conventions, and proactive error handling allow me to build software that is easy to maintain and extend in the future.
